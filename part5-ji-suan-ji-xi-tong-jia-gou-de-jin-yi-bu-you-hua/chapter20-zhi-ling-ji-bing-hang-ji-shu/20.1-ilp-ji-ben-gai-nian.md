---
description: 这一节内容相对较为基础，或许写得有些冗长，但是是融入了初次接触体系结构优化必要的思想。
---

# 20.1 ILP基本概念与简单认识

### ILP基本概念

在本章引言中，我们已经提到ILP实际上是一种**利用指令间潜在并行性进行优化的技术**。最简单的例子便是流水线技术，它将指令的执行分为较短的几个阶段，不同的指令在同一时刻可以处于不同的执行阶段，由此实现了指令级并行。

### 基本块（Basic Block）

请阅读以下代码：

```c
for (int i =0; i <= 999; i++)
    x[i] = x[i] + y[i];
```

相信你能够十分轻松地将这一段代码转化为RISC-V汇编代码。让你的流水线CPU开始执行这些代码，你将会无助地发现，无需几条指令，你的代码便会陷入控制冒险中。这显然不是我们希望看到的，但是很遗憾，对于一般的RISC程序，平均需要分支预测的指令比例通常在15%到25%之间，也就是说，平均约4-7条指令便会遭遇一次控制冒险，这并不是一个好消息。为了更好地描述这一问题，我们引入一个新的概念称为**基本块**。程序中的基本块只有一个入口和一个出口，入口就是其中的第—条语句，出口就是其中的最后一条语句。对一个基本块来说，执行时只从其入口进入，从其出口退出。具体而言：

1. 只有一个入口，表示程序中不会有其它任何地方能通过跳转类指令进入到此基本块中；
2. 只有一个出口，表示程序只有最后一条指令能导致进入到其它基本块去执行。

所以，基本块的一个典型特点是：只要基本块中第一条指令被执行了，那么基本块内所有执行都会按照**顺序**仅**执行一次**。有了基本块的定义后，前述问题可被描述为五个字：基本块太小。并且由此控制冒险严重。不仅如此，基本块中的指令间数据冒险也常常十分严重，因此严重影响ILP所需的指令间潜在并行性。为了优化这一问题，我们不难想到以下三种途径：

1. 为了降低控制冒险的损失，我们可以使用高级的分支预测技术；
2. 面对冲突严重的情况，我们可以通过硬件动态调度进一步挖掘并行性；
3. 同一基本块内冲突严重，我们可以通过静态调度，使得我们可以在不同的基本块的指令间实现ILP。

1中涉及的内容在Chapter08中已经介绍，在20.4中我们会有更多的拓展。对于2和3，我们也将在之后的章节中详细讲解。

事实上，基本块这一概念不仅在体系结构中会被不断强调，在编译原理、程序分析等领域也是很基本的概念，此处不再展开，只表明其重要性。

### 依赖（dependence）与冒险（hazard）

在之前的学习以及本节前述内容中我们知道，指令级并行的瓶颈主要在于两点：

1. 前后指令使用了相同的寄存器，使得指令之间存在**数据依赖**关系；
2. 存在大量跳转指令，使得我们必须执行完跳转指令后才能确定接下来执行的指令，因此指令间还存在**控制依赖**。这一方面跳转指令会拖慢流水线执行效率，还有分支预测错误的可能，另一方面还会使得基本块太小，使得后文介绍的动态调度的空间非常有限。

当然根据我们在流水线一章中学习的内容，结构冒险也是潜在的瓶颈之一，但在以上两个问题严重的情况下，结构冒险的问题便不再突出，毕竟同一时刻能同时执行的指令十分有限。突破上述瓶颈的方案将会在后续章节讲解，这一两小节将为后文的分析引入一些基本概念，由此我们可以认识到，怎样的指令之间并行性会受限。

#### 数据依赖（data dependence）

我们首先来看这样一段代码，这段代码的功能是将内存地址从0(x1)开始到0(x2)结束的每个64位浮点数都加上f2寄存器中存储的值：

```nasm
Loop: 
    fld    f0, 0(x1)      // 将内存中64位浮点数取入 f0 寄存器
    fadd.d f4, f0, f2     // 将取入的数值加上f2中的数值
    fsd    f4, 0(x1)      // 存入修改后的数值
    addi   x1, x1,8      // 读写内存的地址-8
    bne    x1, x2, Loop   // 直到 x1 = x2 不再继续
```

学过流水线数据冒险的我们我们不难发现，假如上述代码在简单的顺序执行流水线CPU上运行，

```nasm
fld    f0, 0(x1)
fadd.d f4, f0, f2
```

这一代码片段中存在一个关于寄存器f0的数据冒险——因为加法指令的源操作数中用到了上一条指令的目的寄存器，于是这两条指令间便有了**数据流动**，即fld指令得到的结果通过f0寄存器流动到fadd.d指令。由此我们便引入第一种指令依赖关系——数据依赖。我们称**指令**$$j$$**数据依赖于指令**$$i$$**（我们称指令**$$j$$**为依赖方，指令**$$i$$**为被依赖方）**，如果

1. 指令$$j$$需要指令$$i$$产生的结果作为其源操作数；
2. 指令$$j$$数据依赖于指令$$k$$，指令$$k$$数据依赖于指令$$i$$。

事实上我们已经十分熟悉上面这种递归式的定义，1中的描述说明了数据依赖产生的base case，2中的描述表明数据依赖可以形成一个“数据依赖链”，这个链条的长度甚至可以贯穿整个程序。

{% hint style="info" %}
从数据流动的角度来看上述定义也是很清晰的，当指令$$i$$有数据流动到指令$$k$$，指令$$k$$又有数据流动到指令$$j$$时，我们可以将数据流动类比为河流，这种流动具有传递性，因此只要在同一数据依赖链上，两条指令间便有数据依赖关系。
{% endhint %}

定义数据依赖后有一个很显然的意义，即存在数据依赖的两条指令之间必须（即使两条指令在数据依赖链条中距离较远也必须如此，可以思考其中原因）依照源程序规定的执行顺序执行，否则无法确保依赖方源操作数的准确性，因此我们的动态调度、静态调度技术需要检测出这种依赖，并保证顺序执行。

还有一点需要强调的是，我们在定义的第一条中并没有限制数据依赖必须是使用了相同寄存器，实际上**访问同样的内存地址也是符合定义的**。但是这增大了检测依赖的难度，因为同一个内存地址可以有不同表达方式，例如可以表示为0(x1)，也可以表示为-12(x2)，这便增大了检测难度。在后续章节中我们会详细讲解现在的技术如何解决这一较为复杂的问题。

#### 名字依赖（name dependence）

我们继续阅读上述代码，可以观察到以下两个代码块：

代码块1：

```nasm
fadd.d f4, f0, f2
fsd    f4, 0(x1)
```

代码块2：

```nasm
addi   x1, x1,8
bne    x1, x2, Loop
```

在代码块1中，f4寄存器同时是两条指令的目的寄存器，在代码块2中，除了与代码块1同样的情况（x1同时作为目的寄存器）外，x1寄存器在作为第一条指令的源操作数的同时是第二条指令的目的寄存器。像这样两条指令都使用了相同的寄存器或内存地址，但两条指令间没有数据流动的依赖，称为**名字依赖**。

事实上，在两个代码块中我们已经将名字依赖分为更具体的两种类型：

假定在一个程序中，指令$$i$$出现在指令$$j$$之前，则有以下两种名字依赖类型：

1. **反依赖（antidependence）**指指令$$j$$写入了指令$$i$$源操作数所在的寄存器或内存地址；
2. **输出依赖（output dependence）**指指令$$i$$和指令$$j$$写入了同一寄存器或内存地址。

显然，代码块1中出现了输出依赖，代码块2中两种名字依赖都存在。学过顺序执行流水线的我们或许会疑惑，因为名字依赖不存在指令间数据流动，因此并不会引起流水线暂停或引发前递。但是在动态或静态调度时，我们常常需要使用乱序执行的技术，当两条指令顺序颠倒时，反依赖会导致指令$$i$$的源操作数被指令$$j$$写入的值破坏，输出依赖会导致最终目的寄存器/地址的值与预期不同，这可能使得后续需要这一寄存器/内存中值的指令获得了错误的操作数。

我们还会发现，我们先前并没有对两条指令源操作数中使用同一寄存器/内存地址定义依赖关系，因为这种情况无论顺序或乱序执行都不会出现上述冲突情况。

但是，名字依赖实际上都可以通过**重命名**的方式消除。

#### 数据冒险（data hazard）

大家不难发现，我们在前文中多次提及数据依赖与数据冒险这两个词，我们十分有必要首先说明这两个词的关系与差别，以免产生混淆：

1. 数据依赖是程序本身的性质，当我们看见一个程序，便可以根据上一节中给出的定义判断存在什么数据依赖。而数据冒险是指在下一个时钟周期中因为指令间存在某些数据依赖，使得下一条指令无法执行的情况。数据冒险的出现是与流水线的执行策略有关的，例如在顺序执行流水线中，输入程序可以存在名字依赖，但不会因此产生流水线数据冒险。
2. 由1可以看出，数据依赖是产生数据冒险的原因，因此我们的优化方向一方面可以减少数据依赖的出现，这一技术在上一节中已有介绍，

#### 控制依赖（control dependence）



<img alt="" class="gitbook-drawing">

在这一节的最后，我们来完成一个简单的练习以巩固所学的知识：

**练习20.1.1**

阅读以下汇编代码并回答问题，假定代码将运行在无前递（forwarding）机制的顺序执行流水线CPU上，跳转指令在ID阶段判断执行，每条指令的理想执行时间均为1个流水线周期：

```nasm
    ld x2, 0(x1)
    ld x3, 8(x1)
L1:
    
L2:
```

1. 请写出上述代码中所有的基本块；
2. 请写出上述代码中所有出现的数据依赖与数据冒险，并计算执行上述代码所需的最小周期数；
3. 请写出你解决2中数据冒险的方式，并根据你的方法，计算出解决数据冒险后执行上述代码所需的最小周期数。
